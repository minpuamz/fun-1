// use symetric to reduce the backtracking only start at 1,2 and 5
// use skip arrays to indicated the one jump transition node 
// use dfs till lenght reached , only proceed if nextStep is not visited and either(1) skip[cur][next] == 0 (2) visited[skip[cur][next]]
// Time O(n!)
// Space O(n)

class Solution {
    public int numberOfPatterns(int m, int n) {
        int[][] skip = new int[10][10];
        skip[1][3] = skip[3][1] = 2;
        skip[1][7] = skip[7][1] = 4;
        skip[3][9] = skip[9][3] = 6;
        skip[7][9] = skip[9][7] = 8;
        skip[1][9] = skip[9][1] = skip[2][8] = skip[8][2] = skip[3][7] = skip[7][3] = skip[4][6] = skip[6][4] = 5;
        boolean[] visited = new boolean[10];
        int res = 0;
        
        for (int i = m; i <= n; i++) {
            // symetric
            res += internal(visited, skip, i -1 , 1) * 4;
            res += internal(visited, skip, i -1, 2) * 4;
            res += internal(visited, skip, i - 1, 5);
        }
        return res;
    }
    
    private int internal(boolean[] visited, int[][]skip, int len, int cur) {
        if (len < 0) return 0;

        if (len == 0) return 1;
        
        if (visited[cur] == true) {
            return 0;
        }
        
        int res = 0;
        visited[cur] = true;
        for (int i = 1; i <= 9; i++) {
            if (!visited[i] && (skip[cur][i] == 0 || visited[skip[cur][i]])) {
                res += internal(visited, skip, len -1, i);
            }   
        }
        visited[cur] = false;
        return res;
        
    }
}
