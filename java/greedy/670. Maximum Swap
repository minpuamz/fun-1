//Time Complexity: O(N), where N is the total number of digits in the input number. Every digit is considered at most once.
//Space Complexity: O(1)
class Solution {
    public int maximumSwap(int num) {
        char[] A = Integer.toString(num).toCharArray();
        // keep reverse mapping
        int[] last = new int[10];
        for (int i = 0 ; i < A.length; i++) {
            last[A[i] - '0'] = i;
        }
        
        for (int i = 0; i < A.length; i++) {
            for (int d = 9; d > A[i] - '0'; d--)  {
                if (last[d] > i) {
                    char tmp = A[i];
                    A[i] = A[last[d]];
                    A[last[d]] = tmp;
                    return Integer.valueOf(new String(A));
                 }
            }
        }
        // not found
        return num;
    }
}

/*
Approach #2: Greedy [Accepted]
Intuition

At each digit of the input number in order, if there is a larger digit that occurs later, we know that the best swap must occur with the digit we are currently considering.

Algorithm

We will compute \text{last[d] = i}last[d] = i, the index \text{i}i of the last occurrence of digit \text{d}d (if it exists).

Afterwards, when scanning the number from left to right, if there is a larger digit in the future, we will swap it with the largest such digit; if there are multiple such digits, we will swap it with the one that occurs the latest.
*/
